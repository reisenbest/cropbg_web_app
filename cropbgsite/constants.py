'''
файл со всеми необходимыми переменными, формирующими меню, функциями, осуществалющими
обработку изображения и всякое такое
''' # что здесь происходит
from cropbgsite.settings import MEDIA_ROOT
from django.core.files.base import ContentFile
import shutil # создание архива, удаление папок
from crop.models import Data
from django.core.files import File # для открытия архива получившегося и его сохранения в БД
from rembg import remove #функция, которая удалят фон у изображения
from PIL import Image
import patoolib
import os
import io



#менюшка сайта, передаваемая в html-шаблоны
menu = [
        {'title':'Main', 'name':'home'},
        {'title': 'Crop Background', 'name': 'crop'},
        {'title': 'About', 'name': 'about'},
        {'title': 'Feedback', 'name': 'feedback'},
        {'title': 'User Guide', 'name': 'userguide'},
        ]
#отдельная переменная для реализации разного отображения меню для авторизованных и неавторизованных пользователей
log_sign = [
        {'title':'LOGIN', 'name':'home'},
        {'title': 'SIGN UP',},
        {'title:' 'Hello, user'}
        ]

#регулярное выражение для валидации данных, которые пользователь вводит в форме, поле "цвет фона"
#4 числа, длинной максимум 3 символа, не более 255, разделены запятыми, отуствуют пробелы.
regular_expression = r'^(?:\d{1,2}|1\d{2}|2[0-4]\d|25[0-5]),(?:\d{1,2}|1\d{2}|2[0-4]\d|25[0-5]),(?:\d{1,2}|1\d{2}|2[0-4]\d|25[0-5]),(?:\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$'

#функция, реализующая функционал удаление фона у одиночного изображения
def cropbg_one_img(image_path,bg_color_one_img=None):
    '''
    :param image_path: путь к изображению, которое пользователь загрузил в форму. Изображение хранится в БД, таблице привязанной к crop.models.Data
    :param bg_color_one_img: цвет фона, который пользователь ввел в форму. ПО умолчанию None. это значит, что пользователь хочет, чтобы фон отсутствовал
    :return:  возвращает байтовое представление обработанного изображения.
    '''
    # Открываем исходное изображение
    input_image = Image.open(image_path)

    #если пользователь указал желаемый фон
    if bg_color_one_img:
        #удаляем пробелы. можно удалить так как это мы проверяем регулярным выражением
        bg_color_one_img = bg_color_one_img.replace(" ", "")

        #делим по запятой. получаем список
        bg_color_one_img  = bg_color_one_img.split(',')

        #превращаем строковые значания в инты
        bg_color_one_img = [int(el) for el in bg_color_one_img]

        #распаковываем наш список в переменные
        R, G, B, A = bg_color_one_img

    # создаем объект BytesIO, который представляет собой буфер в памяти для записи данных в виде последовательности байтов.
    '''
    BytesIO является классом из модуля io, который предоставляет возможность работать с данными в виде байтового потока, 
    подобно файловому объекту. Он может быть использован для временного хранения данных в памяти перед их сохранением или передачей.

    В данном случае, создание BytesIO объекта output_buffer позволяет записывать обработанное изображение в память 
    вместо сохранения его в файл. Это удобно, если требуется получить байтовое представление изображения
    для дальнейшей обработки или передачи через сеть.
    ''' # длинное пояснение
    output_buffer = io.BytesIO()

    if bg_color_one_img:
        #если пользователь указал желаемый фон - передаем значения в бгколор
        output_image = remove(input_image, bgcolor=(R,G,B,A))
    else:
        #если пользователь не указал значения для фона - выполняем удаление фона без доп параметров
        output_image = remove(input_image)

    #сохраняем обработанное изображение без фона в созданный нами буфер памяти для записи данных в виде последовательности байтов
    output_image.save(output_buffer, format='PNG')

    #переводит указатель позиции в буфере обратно в начало. Это необходимо для того, чтобы после сохранения изображения можно было прочитать данные из output_buffer.
    output_buffer.seek(0)

    '''
     возвращает содержимое output_buffer в виде последовательности байтов. 
     Таким образом, функция возвращает обработанное изображение в формате байтов, 
     которое может быть использовано для дальнейшей обработки или передачи.
     '''
    return output_buffer.read()




def cropbg_archive(archive_path, pk, bg_color_archive=None):
    '''

    :param archive_path: путь к архиву в БД, архив загруженный пользователем в форме. поле в модели archive
    :param pk: ключ созданного в БД объекта, к которому будет относится результат раборты фунцкии. нужен для формирования уникальных имен для временных папок
    :param bg_color_archive:  цвет фона, который пользователь ввел в форму. ПО умолчанию None. это значит, что пользователь хочет, чтобы фон отсутствовал
    :return: функция возвращает содержимое результирующего архивного файла в виде байтового объекта.
    '''
    # формируем путь до новой папки, куда будет распокован первоначальный архив
    path_for_archive = MEDIA_ROOT+'/tmp_archive'+'_'+str(pk)

    #так как передаем не сырую строчку экранируем символы во избежане эксцессов. можно оптимизировать
    path_for_archive = path_for_archive.replace('\\', '/')

    # создаем саму папку, куда будет распокован первоначальный архив
    os.mkdir(path_for_archive)

    # Извлекаем архив в указанный каталог, а именно в созданную папку
    patoolib.extract_archive(archive_path, outdir=path_for_archive)

    # Получаем список имен файлов в каталоге
    file_names = os.listdir(path_for_archive)


    # формируем путь до новой папки, куда будут сохранены обработанные изображения для формирования из них архива в дальнейшем
    path_for_result_archive = MEDIA_ROOT+'/tmp_result_archive'+'_'+str(pk)

    # так как передаем не сырую строчку экранируем символы во избежане эксцессов. можно оптимизировать
    path_for_result_archive = path_for_result_archive.replace('\\', '/')

    # Создаем папку для обработанных изображений
    os.mkdir(path_for_result_archive)

    # здесь жтот кусок кода должен быть до цикла for а то он становится списком после первой итерации и далее ошибка
    #проверяем указал ли пользователь желаемый фон для изображений, если да то предобьрабатываем данные
    if bg_color_archive:

        #убираем пробелы, это можно убрать тк это мы проверяем при заполнении формы регулярным выражением
        bg_color_archive = bg_color_archive.replace(" ", "")

        #создаем из значений список
        bg_color_archive = bg_color_archive.split(',')

        #приводим к целочисленному формату элементы списка
        bg_color_archive = [int(el) for el in bg_color_archive]

        #распаковываем список в нужные нам переменные, которые будут отвечать за цвета RGBA
        R, G, B, A = bg_color_archive

    # Обрезаем фон для каждого файла в папке
    for num, file_name in enumerate(file_names):
        #счетчик чтобы я у себя в логах видел че там происходит. К сожалению на стороне пользователя статус-бар недоступен
        #также это счетчик чтобы формировать путь для обработанных изображений
        cnt = num + 1

        # Путь к входному файлу. заходим в папку куда мы распаковали загруженный пользователем архив, и формируем путь к кажому элементу в цикле
        input_path = os.path.join(path_for_archive, file_name)

        # формируем путь к выходному файлу. состоит из имени первоначального файла+его порядковый номер в архиве
        output_path = os.path.join(path_for_result_archive, os.path.splitext(file_name)[0] + '_00' + str(num + 1) + '.png')

        #открываем каждое изображение в режиме на чтение
        with open(input_path, 'rb') as i:
            #открываем сформированый путь в режиме на запись
            with open(output_path, 'wb') as o:
                # Читаем содержимое входного файла
                input_data = i.read()
                # Удаляем фон
                # bgcolor  (R, G, B, A) - можно задать фон у результирующего изображения. по умолчанию None
                # post_process_mask=True - сделает границы объектов резкими.
                # alpha_matting=True  - уточнит края
                # alpha_matting_erode_size >10, еще большее уточненеи края

                if bg_color_archive:
                    #если пользователь указал желаемый цвет фона
                    output_data = remove(input_data, bgcolor=(R, G, B, A))
                else:
                    #если пользователь не указал желаемый фон оставляем без фона
                    output_data = remove(input_data)

                #примитивный статус бар, чтобы видеть в терминале че происходит на каком этапе обраброотка архива
                print('COMPLETE:', cnt, '/', len(file_names))

                # Записываем результат в выходной файл. наполняем таким образом нашу папку обработанными изображениями
                o.write(output_data)
        cnt += 1

    #создаем архив из папки, в которой лежат все наши обработанные изображения
    shutil.make_archive(path_for_result_archive, 'zip', path_for_result_archive)

    # Путь к получившемуся архиву
    result_archive_path = path_for_result_archive + '.zip'

    # Открыть получившийся архивный файл в режиме чтения
    with open(result_archive_path, 'rb') as f:
        # Прочитать содержимое файла и сформировать из него джанговский файл. байтовое представление
        result_archive_file = File(f)

        #указатель в ноль чтобы потом их читать (врзможно в данном случае не нужно
        result_archive_file.seek(0)

        #возвращает архив в виде последовательности байтов
        return result_archive_file.read()



def delete_files_in_user_files():
    '''
    функция удаляет временные папки
    :return:
    '''

    # Путь к папке user_files
    folder_path = MEDIA_ROOT

    # Список имен папок, которые нужно исключить из удаления
    exclude_folders = ['users_images', 'user_archives', 'image_result', 'archive_result']

    # получаем имена всех файлов и папок user_files
    items = os.listdir(folder_path)

    # получаем имена всех файлов (кроме папок) в папке user_files. то есть имя нашего временного архива
    files = [item for item in items if os.path.isfile(os.path.join(folder_path, item))]

    # удаляем эти файлы, таким образом остаются только папки
    for el in files:
        os.remove(os.path.join(folder_path, el))

    # список всех папок в папке user_files
    tmp_list = []

    # все папки в папке user_files добавляем во врепменный список
    for names in os.listdir(folder_path):
        tmp_list.append(names)

    # итерируем по этому списку и удаляем все папки, кроме тех, что у нас в списке exclude_folders
    for el in tmp_list:
        if el not in exclude_folders:
            shutil.rmtree(os.path.join(MEDIA_ROOT, el))



